# javasript

3.26

看了[这篇文章](https://github.com/alsotang/node-lessons/blob/master/lesson11%2FREADME.md)，知道了js里函数可以当做变量一样传来传去。之前从没接触过函数式编程。有几个地方说的类，构造函数等是在和c++类比。

## 闭包
有点像把函数看成一个对象，一个函数就是一个作用域，var声明的变量才是在作用域内的变量，没加var声明的话就是默认为全局变量。外部的函数不能访问在内部函数里声明的变量，而内部函数可以访问外部函数声明的变量。

## this
跟C++里的有点类似，只不过设计的人把它写残了。大概就是假如函数有所属对象，函数里面的this就是指这个对象，函数没有所属对象的时候，例如`var a=function(x){return this;};`，此时的this指向全局(golbal)。可以手动把当前对象的绑定到另外的对象上去，用apply,call,bind，绑定之后里面的this就是指向当前对象。

## new
new 一个function实例的时候，返回的是一个对象，也验证了函数就是对象这个道理。所以可以这么理解，定义一个函数就像定义一个类一样，然后new的时候就是创建一个实例。
```js
function myfunc(arg1,arg2){
    this.a = arg1;
    this.b = arg2;
    this.c = function(){};
}
var a = new myfunc(1,2);//这个a就是一个对象,然后这个对象的属性有a和b,方法有c。像不像类的初始化？函数定义像不像构造函数？
```
## call,apply
这两个函数都是预定义的意思，区别只有一个，后者需要把参数装到数组里传进去。不知道这玩意有什么用，直接返回不是一样吗。(node.js的call不一样，明天再看一下。还有闭包)
```js
function myFunction(a, b) {
    return a * b;
}
myObject = myFunction.call(myObject, 10, 2);     // Will return 20

function myFunction(a, b) {
    return a * b;
}
myObject = myFunction.call(myObject, 10, 2);     // Will return 20
```

---

3.27

今天看了JavaScript语言精粹。验证了我昨天的一些猜想。这语言很多设计失误，绝壁不是一个语言专家设计出来的，更像是一个实验性的产物，想到什么特性就不计后果的加上去，留下了很坑。

## 对象
javascript对对象的定义是：可变的键控集合。对象有属性名，这个可以是任何非关键字的标识符或者“a-b”这种，不过后者应该要避免感觉太丑了。属性对应的值可以是任何表达式。
* 取值。`a.p`或者`a["p"]`，假如没有这个属性就返回undefined。这里它举得例子让我发现了一个很奇特的事情。`"b"||"a"`逻辑运算符返回的居然是操作数本身。所以可以利用||或者&&来做检查和填充一个默认值。
* 引用。对象之间永远不会被复制。也就是说，把一个对象赋值给另外一个对象，这两个变量就共享一个对象了。那我要复制多个变量怎么办呢？？
* 原型。每个对象都有原型链。对象字面量创建的对象，原型链里就一层，`Object.prototype`。函数字面量好像有个`Function.prototype`，然后它会连接到自己`Object.prototype`。原型我的理解就是基类吧。你给基类增加属性，子类都将受益。
* 反射。`typeof`可以检查出对象的类型，你可以用它来检查一个对象的属性是否存在，存在的话会返回对应的类型，不存在则会返回undefined。还有一个方法，`hasOwnProperty`会检查对象独有的属性，不会检查原型链中的，有的话就返回true。
* 遍历。遍历一个对象`for(x int obj)`。这会遍历所有的属性，包括原型链中的。(那些内置的也会吗？)所以需要自己去筛掉不用的属性。
* 减少变量污染。用一个顶层对象来包住你的代码，这或许是有点用。

## 函数
明天再写。

3.28
### 闭包。
闭包的定义就那么一句话，一个函数可以访问它被创建时所在的上下文环境。大多数情况是在说内部函数能访问外部函数的变量。在js里，函数是可以嵌套定义的，因此确实需要引入一个像闭包这样的概念。
* 那么闭包可以用来干嘛呢。

    ```js
    var myobj = (function(){
        var value = 0;
        return {
            getValue : function(){
                return value;
            }
        };
    }());//调用匿名函数，返回一个有getValue方法的对象，传给myobj，这时候对于这个对象来说value就变成了私有属性，因为只能通过getValue方法获得。
    ```
    
    这里的所说的私有属性只是一种抽象的描述，然而这个变量真正应该是在定义的时候的上下文中，那么就会有一个疑问，假如这个变量是在外层函数中定义的，当函数结  束的时候，如果内层函数用到了这个变量，那么这个变量就一直不会消失，那这个变量是存在于哪的呢？我想到一个猥琐的方法，那就是在外层函数结束的时候把和内层函数相关的变量弄到内层函数的活动区间里去。不知道设计者是怎么做的。

* 闭包的坑。~因为可以访问外部函数的变量，有时候碰到内部函数是异步调用之类的时候，需要明白这个道理，所谓的访问外部变量是指的引用而不是复制，这样也就没有坑了。对这种情况，有一个优雅点的弥补方法。在我看来，无论怎么做，本质上都是用了函数参数传递时候的复制实现的。~ (Corrected 2017.4.5) 函数传参传的是一个新的参数变量，传参数的时候会把传入变量的引用的地址复制给这个参数变量用，即共享那块真正存有值的内存地址。而闭包下的函数查找变量时，用的是外层函数里那个变量自身，所以始终等于外层函数变量指向的内存地址。
   
   ```js
    var a = function(){
            var i = 1;
            var helper = function(i){
                return function(){
                    console.log(i);
                };
            };
            var c = function(){
                setTimeout(helper(i),200);
            };
            c();
            i = 2;
    };
    a();
    //你也可以这样，本质都一样，都是通过参数的复制。
    var a = function(){
        var i = 1;
        var c = function(i){
                setTimeout(function(){console.log(i);},200);
        };
        c(i);
        i = 2;
    };
    a();
    ```

### 函数调用。
* 方法调用。`obj.method();`
* 构造器调用。`var f = new Obj("key");`
* 普通调用。`func_name();`和匿名函数调用`(function(){}());`。我觉得匿名函数调用很有意思，这书上居然不介绍，只说了匿名函数定义。现在终于知道为啥有人说函数式编程可以把代码写成一行了。
* 还有apply调用，这种很奇怪的东西。。

### 模块。
模块的思想可以让你用javascript实现封装。主要还是利用前面讲过的闭包性质实现的。这个有点厉害。

### 级联。
就是把函数返回值设置成`this`,然后`obj.func_a().func_b()`这样一直点完所有的方法。这个还行。

### 柯里化。
没看懂。concat是干嘛的？

### 记忆化。
利用闭包，把函数的计算结果存起来。可以大大减少重复计算。书里介绍了一个技巧，通过设计产生另一个函数的函数，大大减少工作量。他写的这个通用的记忆函数，没看懂但是觉得很吊。P45


3.29
## 方法
js里的标准类型很多都有专属于自己的一些方法。这里有个疑问，自己通过prototype加上去的方法按理说是具有生命周期的吧，不然会乱套的。(刚刚做了实验，特么自己添加的方法竟然全局有效。。)
* Array。
    * concat。就是把自己和参数里的对象连接起来生成一个新数组。
    * join。就是把数组变成字符串，其中separator可以自己设置。
    * pop。push。shift。unshift。增删首尾的元素。
    * reverse。反转
    * sort(comparefn)。js自带的比较函数很蠢，所以需要自己设置。
    * slice。截取
    * splice。删除和替换
* Function。
    * apply。
    * bind。绑定一个对象给当前这个函数用。相当于把对象里的属性复制过来，到了函数对象里了。
* Number。
    * toExponential,toFixed,toPrecision 参数是0~20的整数来控制精度
    * toString(radix) 参数是2~36的整数，来控制基数，估计就是进制吧。
* Object
    * hasOwnProperty。判断该对象是否存在某个属性
* RegExp
    * exec(string)。这个返回的是数组，下标为0的元素是匹配到的字符串，后面的是分组捕获的文本。
    * test(string)。这个就只返回bool值。
* string
    * charAt(pos)。返回只有一个字符的字符串(js没有char类型)。
    * charCodeAt(pos)。返回字符码值。
    * concat。连接，通常用+就行了
    * indexOf(searchString, position)。查找子串，可以设置从哪开始找。
    * lastIndexOf。和上面一样，从末尾开始找
    * match。replace。split。substring。等等就懒得说了。
    * 可以看出脚本语言对于字符串的处理能力还是很强的。这取决于它的应用环境。


5.22
## Lambda表达式
```js
    // js里原来的匿名函数，和立即调用的写法。
    (function(x,y){return x+y;})();
    // 新标准里的特性，lambda表达式。这看上去就只是上种写法的语法糖而已啊。= =
    ((x,y)=>x+y)(1,2);
```

7.27
## js里的正则
刚刚看到的，允许直接这样写，很简洁：`\abcdefg\.test(str);`

匹配`(0,20]`区间的数字：`/^(?:[1-9]|1[0-9]|20)$/.test(str);`

顺便记一下

* `(pattern)`，pattern会存为一个分组
* `X(?:pattern)`不保存，只提供了括号的优先级作用，匹配的是`Xpattern`。
* `X(?=pattern)`正向预查，不保存，看X后面是不是等于pattern，是的话匹配`X`
* `X(?!pattern)`~反~正向预查，不保存，看X后面是不是不等于pattern，是的话匹配`X`

反向预查的语法是

* (?<=pattern)X 反向匹配
* (?<!pattern)X 反向不匹配

但是！js 并不支持反向预查，一直以为上面那个`(?!pattern)`是反向预查，汗...
