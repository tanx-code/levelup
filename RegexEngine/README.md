# RegexEngine，正则引擎

## 介绍
Old文件夹里是去年自学编译原理的时候写的。万事开头难啊。

New文件夹里是把轮子哥的代码用STL和C++11改写了一遍。因为，上面那个花了很多时间又写得不好的版本，已经变成了我的心患，不给自己一个满意的交代的话，心里总是不舒坦。基于我已经知道正则引擎的实现细节，所以这一边我的重点是学习他人的软件架构，研究怎么才能写出清晰的代码，以及设计出简洁不冗余的数据结构。

这个版本支持的功能：
* 字符集合 `a, [a-b], [^a-b0_9], /.rnt\/()+*?{}[]<>^$!=SsDdLlWw, [/rnt-[]\/^$]`
* 循环 `a{3}, a{3,}, a{1,3}, a+, a*, a?`
* 顺序 `ab`
* 选择 `a|b`

不支持子串和捕获。


## 实现
下面来讲解一下新版本的实现过程。

**阶段一**

首先是正则表达式的parse过程。我以前还不知道AST和递归下降的时候，是直接在一个switch里同时分析了语法和生成了nfa，也就是说只分析了一遍字符串，完成了这两件事情，因为我没有支持字符集，不然这种做法是一定会跪的。成熟的做法当然是先生成抽象语法树了。这个过程我发现，轮子哥的做法和我写那个解释器的时候学到的做法是同一个套路，这个套路的本质是预测分析，加递归下降。教科书上的那些LL LR，我真的不想去研究，我觉得现在这个方法就已经很万能了。在这阶段，难点是设计好这些expression类。对了，CharRange这个数据结构是我以前没用到的，有了它就能轻易描述字符集了，轮子哥这里希望能处理UTF-16，所以字符范围设置为1-65535。

**阶段二**

有了AST之后，当然要遍历这棵树。还是那个套路里的东西，用虚函数来实现语法树的遍历。把每个类型各自的虚函数都填好，然后去调用根节点的虚函数，这样调用关系就会自动递归下去。这个不多说，就是套路。然而，轮子哥这里引入了一个Visitor模式，这是个新鲜玩意，我琢磨了半天。为了让虚函数能同时实现不同需求的功能，比如构造nfa，字符集正规化等，以前的那种直接把要处理的逻辑写在虚函数里面的做法就不行了，因为不同的需求，需要虚函数做不同的事情，或者返回不同的类型，虽然你去把虚函数重载应该也可以，但这样做的后果就是，所有的这些表达式类都含了一个巨大的虚函数。这可不行，代码又变的不清楚了，我们的目标是写出清晰简洁的结构，那么要怎么才能把算法的实现从虚函数里剥离出来呢。

```cpp
class IRegexExpressionAlgorithm
{
public:
		virtual void visit(CharSetExpression* expression) = 0;
		virtual void visit(LoopExpression* expression) = 0;
		virtual void visit(SequenceExpression* expression) = 0;
		virtual void visit(AlternateExpression* expression) = 0;
		virtual void visit(BeginExpression* expression) = 0;
		virtual void visit(EndExpression* expression) = 0;
};
...
// apply函数是所有表达式类从基类继承而来的虚函数
void CharSetExpression::apply(IRegexExpressionAlgorithm& algorithm)
{
		algorithm.visit(this);
}
...
class 具体的算法类 : public IRegexExpressionAlgorithm
{
  void visit(CharSetExpression* expression)
  {
		  result = apply(expression);
  }
  
  returnType apply (CharSetExpression* expression )
  {
  }
```

`IRegexExpressionAlgorithm`表示算法类的虚基类。这样做的效果是，既统一了apply函数的格式，又通过this指针成功的将目标交给了对应的算法类了。然后在算法类里只要根据不同的表达式类来重载visit函数就行了。其实你会发现，你还是不能在visit函数里去写算法逻辑，因为不难看出所有的visit函数在函数参数上是不能改变的，可是递归下降的时候往往需要返回值，因为有时候那个返回值携带着很有用的信息。所以，还得再在类里面重载对应数量的专门用来写逻辑的函数(这里还是命名的apply)，这时候返回类型(上面写的的returnType)你就能随性所欲的填了，需要的话apply参数也是可以加的，为此轮子哥还设计了一个模版类，不过我觉得既然想要的目标达到了（把算法实现从表达式类的虚函数里剥离出来），那就先不搞那么复杂，不过我也弄明白了轮子哥为什么要用模版，因为不用模版的话，每一个算法类，仅因为返回值类型不同，就要把那些visit函数再抄一遍。可这是小事，况且我又不全抄，我只打算抄他代码里的纯的那部分，capture那些暂时不管。所以，我最终的实现是，舍弃模版，写了两个类，一个是为了测试用的，比较生成的AST和手写的AST是否相同的算法类；另一个是生成带epsilon边的NFA的算法类，并且把他的CharSetNormalize算法用一个小函数塞在这个类里解决了。

**阶段三**

开始单元测试。刚刚正则表达式parse过程没测试，AST生成过程也没测试，所幸的是通过比较最后生成的AST和手写的AST就能同时完成两阶段的测试了。测试里的内容我大多数都是直接用的轮子哥的。把那些测试用例全过了就可以走下一步了。

**阶段四**

自动机的生成。先利用Thompson算法，通过在基本的NFA上应用连接、循环、选择操作，就能构造出完整的带epsilon边的NFA了；然后再用求每个状态的epsilon边闭包的方法，去掉epsilon边；然后是用子集构造法，把一些可以合并的状态合并成一个状态，从而达成nfa到dfa的转换。在这一阶段中，没有什么创新的，代码的结构也比较清晰，因为主要的变化都体现在了数据的流动上，`ε-nfa -> nfa -> dfa`。每当构造完下一个阶段的数据，前一个阶段的数据就可以扔掉了，就像火箭发射，多级推进一样。因为这里的代码就只是书上讲的算法的实现，我没有兴趣去重写了，直接复制了轮子哥的。

**阶段五**

状态机的单元测试。只能把里面的信息全都打印出来了，拿结果去和轮子哥的测试结果对比就行了，一模一样的话就过了。我这里顺手用graphviz，生成了下它们的状态转换图，你可以[在这个目录里看到](https://github.com/arctanx0/RegexEngine/tree/master/RegexEngine_New/UnitTest/PrintedData/DotGraph)。

**阶段六**

核心的东西都弄完了，写个头文件供使用者调用就好了。匹配的过程，就是把dfa的信息打到表里，然后利用表来驱动匹配。接口写完了也要测试一下。

## 总结

* 要想让程序的结构清晰，学会拆分是关键，设计模式我也一直没看，里面应该揭示了很多这种解耦的方法吧。
* 设计数据结构的时候，不一定要把它现在和将来要描述的信息都一股脑写出来，有时候抽象一下会简洁很多，比如让`一个复杂的数据 = 一个简单的数据 + 一个方法`，不就简化了么。
* 测试用例设计的好，直接根据用例去调试程序，效率会很高。


## 截图

附一张中文匹配的截图

![](http://7xrkyy.com1.z0.glb.clouddn.com/16-7-6/88973751.jpg)

